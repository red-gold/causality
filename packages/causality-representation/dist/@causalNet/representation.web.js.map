{"version":3,"sources":["webpack://@causalNet/representation/webpack/universalModuleDefinition","webpack://@causalNet/representation/webpack/bootstrap","webpack://@causalNet/representation/external \"causal-net.utils\"","webpack://@causalNet/representation/external \"causal-net.core\"","webpack://@causalNet/representation/./src/vectorMetrics.mixins.js","webpack://@causalNet/representation/external \"causal-net.storage\"","webpack://@causalNet/representation/external \"causal-net.memcache\"","webpack://@causalNet/representation/./src/universalEmbedding.js","webpack://@causalNet/representation//home/huynhnguyen/github/causality/node_modules/@babel/runtime/helpers/objectSpread.js","webpack://@causalNet/representation//home/huynhnguyen/github/causality/node_modules/@babel/runtime/helpers/defineProperty.js","webpack://@causalNet/representation/(webpack)/buildin/global.js","webpack://@causalNet/representation/external \"@tensorflow-models/universal-sentence-encoder\"","webpack://@causalNet/representation/./src/representation.mixins.js","webpack://@causalNet/representation/./src/wordEmbedding.mixins.js","webpack://@causalNet/representation/./src/Lookup/chunkLookup.mixins.js","webpack://@causalNet/representation/./src/Lookup/tokenLookup.mixins.js","webpack://@causalNet/representation/./src/wordEmbeddingFunctor.mixins.js","webpack://@causalNet/representation/./src/functor.js","webpack://@causalNet/representation/./src/causalNetEmbedding.js","webpack://@causalNet/representation/./src/index.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__3__","__WEBPACK_EXTERNAL_MODULE__4__","__WEBPACK_EXTERNAL_MODULE__9__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","VectorMetricMixins","BaseEmbeddingClass","[object Object]","sentence1","sentence2","x","sentenceEncode","reshape","y","dot","div","norm","mul","global","causal_net_utils__WEBPACK_IMPORTED_MODULE_0__","causal_net_core__WEBPACK_IMPORTED_MODULE_1__","_vectorMetrics_mixins__WEBPACK_IMPORTED_MODULE_2__","__webpack_exports__","platform","mixWith","Tensor","constructor","super","use","model","fetch","load","sentences","Error","embed","target","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","forEach","obj","configurable","writable","g","Function","e","window","RepresentationMixins","BasePipelineClass","Representation","representation","assert","beInstanceOf","connect","configureLink","embeddingConfig","logger","log","setRepresentationByConfig","netConfig","EmbeddingConfig","Embedding","String","WordEmbeddingMixins","unknowVec","f","zeroVec","VecSize","T","encodedSentences","tokens","vecs","transform","encode","tensor","mean","push","stack","TokenLookUp","ChunkLookUp","missCacheTokens","token","vec","debug","tokenChunkIds","chunkIds","F","mapTokenToChunkIds","TokenChunkIdMapper","masterchunk","chunkId","console","chunk","queryChunk","updateChunkLookUp","objectSpread_default","reduce","finalVecs","_vec","undefined","ChunkLookupMixins","BaseWordEmbeddingClass","Storage","Promise","async","resolve","reject","ChunkPath","embeddingSavePath","getItem","JSON","parse","err","UpdateChunkPath","setItem","ChunkUrl","baseLink","query","TokenLookUpMixins","MemCache","error","WordEmbeddingFunctorMixins","BaseFunctionClass","mapper","R","tokenChunkMap","map","_chunkIds","unzip","uniq","vecSize","range","functor","BaseFunctor","causalNetEmbedding","BaseTensor","StorageMixins","MemCacheMixins","ChunkLookUpMixins","storage","cache","embeddingDescriptionPath","vecsize","link","refresh","getDescription","forceFecth","description","descriptionItem","load description from storage","queryDescription","getIn","chunkLookUp","startsWith","jsonUtils","fetchJson","readJSON","DescriptionLink","stringify","indexDBStorage","memDownCache","representation_mixins","universalEmbedding","wordEmbedding_mixins","chunkLookup_mixins","tokenLookup_mixins","wordEmbeddingFunctor_mixins"],"mappings":"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","file":"@causalNet/representation.web.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"causal-net.utils\"), require(\"causal-net.core\"), require(\"causal-net.storage\"), require(\"causal-net.memcache\"), require(\"@tensorflow-models/universal-sentence-encoder\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"causal-net.utils\", \"causal-net.core\", \"causal-net.storage\", \"causal-net.memcache\", \"@tensorflow-models/universal-sentence-encoder\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@causalNet/representation\"] = factory(require(\"causal-net.utils\"), require(\"causal-net.core\"), require(\"causal-net.storage\"), require(\"causal-net.memcache\"), require(\"@tensorflow-models/universal-sentence-encoder\"));\n\telse\n\t\troot[\"@causalNet/representation\"] = factory(root[\"causal-net.utils\"], root[\"causal-net.core\"], root[\"causal-net.storage\"], root[\"causal-net.memcache\"], root[\"@tensorflow-models/universal-sentence-encoder\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__3__, __WEBPACK_EXTERNAL_MODULE__4__, __WEBPACK_EXTERNAL_MODULE__9__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","/**\n * This VectorMetricMixins class is provide methods for comparing vector representation of different sentences\n * @class VectorMetricMixins\n * @extends  BaseEmbeddingClass\n */\nconst VectorMetricMixins = (BaseEmbeddingClass)=> class extends BaseEmbeddingClass{ \n    \n    /**\n     * return the eucleudian distance between two representation vectors\n     * @returns { Array } vec\n     */\n    async encodeMatching(sentence1, sentence2){\n        let x = await this.sentenceEncode([sentence1]);\n        x = x.reshape([-1]);\n        let y = await this.sentenceEncode([sentence2]);\n        y = y.reshape([-1]);\n        return x.dot(y).div(x.norm().mul(y.norm()));\n    }\n};\n\nexport default VectorMetricMixins;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","module.exports = __WEBPACK_EXTERNAL_MODULE__4__;","import { platform, fetch } from 'causal-net.utils';\nimport { Tensor } from 'causal-net.core';\nimport { default as VectorMetricMixins } from './vectorMetrics.mixins';\n\n/**\n * This UniversalEmbedding provide methods for transform sentences into \n * its single vector representation \n * based on [use](https://github.com/tensorflow/tfjs-models/tree/master/universal-sentence-encoder)\n * \n * @class UniversalEmbedding\n * @extends {Tensor}\n * @example\n * [EXAMPLE ../examples/universalEmbedding.babel.js]\n */\nclass UniversalEmbedding extends platform.mixWith(Tensor, \n    [ VectorMetricMixins ]){\n    \n    constructor(){\n        super();\n        /**\n         * @private { TensorModel } \n         */\n        this.use = require('@tensorflow-models/universal-sentence-encoder');\n        this.model = null;\n    }\n    \n    async connect(){\n        if(global){\n            //TODO: make better with platform\n            global.fetch = fetch.fetch;\n        }\n        this.model = await this.use.load();\n        return this;\n    }\n\n    async sentenceEncode(sentences){\n        if(!this.model){\n            throw Error(`model is not connect`);\n        }\n        let embeddings = await this.model.embed(sentences);\n        return embeddings;\n    }\n}\nexport default new UniversalEmbedding();","var defineProperty = require(\"./defineProperty\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nmodule.exports = _objectSpread;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__9__;","import { Tensor } from 'causal-net.core'; \nimport { assert } from 'causal-net.utils';\n/**\n * This mixin class provides attributes: **Representation**.\n * @class RepresentationMixins\n * @extends  BasePipelineClass\n * @example\n * [EXAMPLE ../examples/embeddingMixins.babel.node.js]\n */\nconst RepresentationMixins = (BasePipelineClass)=> class extends BasePipelineClass{ \n    /**\n     * Return Embedding instance\n     *\n     * @readonly\n     * @memberof RepresentationMixins\n     */\n    get Representation(){\n        if(!this.representation){\n            throw Error('representation is not set');\n        }\n        return this.representation;\n    }\n    \n    set Representation(representation){\n        assert.beInstanceOf(representation, Tensor);\n        this.representation = representation;\n    }\n    /**\n     * Load configure of pretrained vector from either local folder or remote server. \n     * After connect, the result is cached for next time init.\n     * @param { URL|FilePath } link - link to load\n     * @param { boolean } [refresh=false] - force to discard local cache\n     * @returns { Promise }\n     * @memberof RepresentationMixins\n     */\n    async connect(){\n        if(super.connect){\n            super.connect();\n        }\n        let configureLink = this.embeddingConfig;\n        this.logger.log(`representation connect to ${configureLink}`);\n        await this.Representation.connect(configureLink);\n    }\n    /**\n     * set embedding for pipeline\n     * @param { Object } netConfig - contain Embedding instance and Embedding configure\n     * @memberof RepresentationMixins\n     */\n    setRepresentationByConfig(netConfig){\n        let { EmbeddingConfig, Embedding } = netConfig.Representation;\n        assert.beInstanceOf(EmbeddingConfig, String);\n        this.Representation = Embedding;\n        this.embeddingConfig = EmbeddingConfig;\n    }\n};\nexport default RepresentationMixins;    ","/**\n * This WordEmbeddingMixins class is provide methods for transforn sentences, tokens to vectors\n * @class CausalNetEmbedding\n * @extends  BaseEmbeddingClass\n */\nconst WordEmbeddingMixins = (BaseEmbeddingClass)=> class extends BaseEmbeddingClass{ \n    /**\n     * return default replacement for unknown vec. Currently it is set to zeros\n     * @returns { Array } vec\n     */\n    unknowVec(){\n        return this.f.zeroVec(this.VecSize);\n    }\n        \n    /**\n     * return the vectors of tokenized sentences\n     * This function require sentence to be tokenized via preprocessing\n     * @param { Array } tokens - array of string tokens of sentence\n     * @returns { Tensor } encoded sentences\n     */\n    async sentenceEncode(sentences){\n        const T = this.T;\n        let encodedSentences = [];\n        for(let tokens of sentences){\n            let vecs = await this.transform(tokens);\n            let encode = await T.tensor(vecs).mean(0);\n            encodedSentences.push(encode);\n        }\n        return T.stack(encodedSentences);\n    }\n    /**\n     * Transform tokenized sentences into tensor vectors\n     * @param { Array } tokens - 2d array for token of sentences\n     * @returns { Tensor } 2d tensor represent vectors of each input sentences\n     * @example\n     * let sentVec = await causalNetEmbedding.sentenceEncode([ ['this', 'is', 'test'] ]);\n     */\n    async transform(tokens){\n        const TokenLookUp = this.TokenLookUp, ChunkLookUp = this.ChunkLookUp;\n        \n        let vecs = [], missCacheTokens=[];\n        for(let token of tokens){\n            let vec = await TokenLookUp(token);\n            this.logger.debug({[token]: vec});\n            if(vec === null){\n                missCacheTokens = [...missCacheTokens, token];\n            }\n            vecs = [...vecs, token];\n        }\n        if(missCacheTokens.length === 0){\n            return vecs;\n        }\n        \n        let {tokenChunkIds, chunkIds} = \n            this.F.mapTokenToChunkIds(missCacheTokens, this.TokenChunkIdMapper);\n        \n        this.logger.debug({tokenChunkIds, chunkIds});\n        let masterchunk = {};\n        for(let chunkId of chunkIds){\n            if(chunkId !== null){//not in chunk\n                console.log('lookup');\n                let chunk = await ChunkLookUp(chunkId);\n                if(chunk === null){\n                    chunk = await this.queryChunk(chunkId);\n                    await this.updateChunkLookUp(chunkId, chunk);\n                }\n                masterchunk = {...masterchunk, ...chunk};\n            }\n        }\n        \n        let finalVecs = vecs.reduce((finalVecs, vec)=>{\n                            if( typeof(vec) === \"string\" ){\n                                let _vec = masterchunk[vec];\n                                if(_vec === undefined){\n                                    _vec = this.unknowVec();\n                                }\n                                finalVecs.push(_vec);\n                            }\n                            else{\n                                finalVecs.push(vec);\n                            }\n                            return finalVecs;\n                        }, []);\n        return finalVecs;\n    }   \n};\nexport default WordEmbeddingMixins;","/**\n * This ChunkLookupMixins class provide mixins for chunk lookup that first look from the cached chunk then\n * fetch and cache new chunk\n * @class ChunkLookupMixins\n * @extends {  BaseWordEmbeddingClass } \n */\nconst ChunkLookupMixins = ( BaseWordEmbeddingClass )=> class extends BaseWordEmbeddingClass{ \n    \n    /**\n     * Return the storage lookup function\n     * @readonly\n     */\n    get ChunkLookUp(){\n        const Storage = this.Storage;\n        return (chunkId)=>{\n            return new Promise(async (resolve, reject)=>{\n                try{\n                    const ChunkPath = this.embeddingSavePath + chunkId;\n                    let chunkItem = await Storage.getItem(ChunkPath);\n                    let chunk = chunkItem[ChunkPath];\n                    resolve(JSON.parse(chunk));\n                }\n                catch(err){\n                    resolve(null);\n                }\n            });\n        };\n    }\n   /**\n    * Update the storage lookup\n    * @param { String|Number } chunkId - id in positive integer range\n    * @param { Object } chunk - chunk object containing token keys and correponding vec value\n    * @returns { String } - updated chunk path in storage\n    */\n   async updateChunkLookUp(chunkId, chunk){\n        const Storage = this.Storage;\n        const UpdateChunkPath = this.embeddingSavePath + chunkId;\n        return await Storage.setItem(UpdateChunkPath, chunk);\n    }\n    /**\n     * Query chunk either read from file or fetch from remote server\n     * @param { String|Number } chunkId - id in positive interger range\n     * @returns { Object }  chunk object containing token keys and correponding vec value\n     */\n    async queryChunk(chunkId){\n        const ChunkUrl = `${this.baseLink}wordvec_chunk_${chunkId}.json`;\n        return await this.query(ChunkUrl);\n    }\n   \n};\nexport default ChunkLookupMixins;","const TokenLookUpMixins = (BaseWordEmbeddingClass)=> class extends BaseWordEmbeddingClass{ \n    get TokenLookUp(){\n        const MemCache = this.MemCache;\n        return (token)=>{\n            return new Promise(async (resolve, reject)=>{\n                try{\n                    let vec = await MemCache.getItem(this.embeddingSavePath + token);\n                    resolve(vec);\n                }\n                catch(err){\n                    resolve(null);\n                }\n            });\n        };\n    }\n    /**\n     * Update token look up\n     * @param { String } token - token \n     * @param { Array } vec - vector representation of token\n     */\n    async updateTokenLookUp(token, vec){\n        console.error('this is update');\n        const MemCache = this.MemCache;\n        await MemCache.setItem(this.embeddingSavePath + token, vec);\n    }\n};\nexport default TokenLookUpMixins;\n","const WordEmbeddingFunctorMixins = (BaseFunctionClass) => class extends BaseFunctionClass{\n    /**\n     *\n     * @param { Array } tokens - list of tokens to find coresponding ids\n     * @param { Function } mapper - \n     * @returns \n     */\n    mapTokenToChunkIds(tokens, mapper){\n        const R = this.R;\n        const TokenChunkIdMapper = mapper;\n        let tokenChunkMap = tokens.map( t => {\n            let chunkId = TokenChunkIdMapper(t);\n            return [[t, chunkId], chunkId]; \n        });\n        let [tokenChunkIds, _chunkIds] = this.unzip(tokenChunkMap);\n        let chunkIds = R.uniq(_chunkIds);\n        console.log({chunkIds, tokenChunkIds});\n        return {tokenChunkIds, chunkIds};\n    }\n    /**\n     * return zero vector given the vec size\n     * @param { Number } vecSize - positive integer indicates vector length\n     * @returns { Array } zero vector\n     */\n    zeroVec(vecSize){\n        return this.R.map(()=>0,this.R.range(0, vecSize));\n    };\n};\nexport default WordEmbeddingFunctorMixins;","import { Functor as BaseFunctor } from 'causal-net.core';\nimport { platform } from 'causal-net.utils';\nimport { default as WordEmbeddingFunctorMixins } from './wordEmbeddingFunctor.mixins';\n/**\n * This Function class provides methods for common used ultilities function\n * @export\n * @class Function\n * @extends BaseFunctor\n */\n\nclass Functor extends platform.mixWith(BaseFunctor, \n        [WordEmbeddingFunctorMixins]){\n    constructor(){\n        super();\n    }\n}\n\nexport default new Functor();","import { Tensor as BaseTensor } from 'causal-net.core';\nimport { platform, fetch, jsonUtils } from 'causal-net.utils';\nimport { StorageMixins, indexDBStorage } from 'causal-net.storage';\nimport { MemCacheMixins, memDownCache } from 'causal-net.memcache';\nimport { default as WordEmbeddingMixins } from './wordEmbedding.mixins';\nimport { default as ChunkLookUpMixins } from './Lookup/chunkLookup.mixins';\nimport { default as TokenLookUpMixins } from './Lookup/tokenLookup.mixins';\nimport { default as VectorMetricMixins } from './vectorMetrics.mixins';\nimport { default as functor } from './functor';\n/**\n * This CausalNetEmbedding provide methods for transform raw tokenized sentence into \n * its single vector representation\n * mixWith:\n *         [   StorageMixins, \n *             MemCacheMixins,\n *             TokenLookUpMixins,\n *             ChunkLookUpMixins,\n *             WordEmbeddingMixins ])}\n * @class CausalNetEmbedding\n * @extends  BaseTensor\n * @example\n * [EXAMPLE ../examples/causalNetEmbedding.babel.node.js]\n */\nclass CausalNetEmbedding extends platform.mixWith(BaseTensor, \n        [   StorageMixins, \n            MemCacheMixins,\n            TokenLookUpMixins,\n            ChunkLookUpMixins,\n            VectorMetricMixins,\n            WordEmbeddingMixins ]){\n    constructor(fetch, storage, cache, functor){\n        super();\n        this.fetch = fetch;\n        this.Storage = storage;   //store configure\n        this.MemCache = cache;    //store chunks\n        this.F = functor;\n        this.embeddingSavePath = '/embedding/';\n        this.embeddingDescriptionPath = this.embeddingSavePath + 'description.json';\n    }\n    /**\n     * Return veczie in positive number\n     *\n     * @readonly\n     * @memberof CausalNetEmbedding\n     */\n    get VecSize(){\n        if(!this.vecsize){\n            throw Error('vecsize is not set');\n        }\n        return this.vecsize;\n    }\n    /**\n     * Load configure of pretrained vector from either local folder or remote server. \n     * After connect, the result is cached for next time init.\n     * @param { URL|FilePath } link - link to load\n     * @param { boolean } [refresh=false] - force to discard local cache\n     * @returns { Promise }\n     * @memberof CausalNetEmbedding\n     */\n    async connect(link, refresh=false){\n        this.baseLink = link;\n        return await this.getDescription(refresh);\n    }\n    /**\n     * This method is called by connect\n     * @private\n     * @param {boolean} [forceFecth=false]\n     * @returns\n     * @memberof CausalNetEmbedding\n     */\n    async getDescription(forceFecth=false){\n        if(!this.description){\n            try{\n                let descriptionItem = await this.Storage.getItem(this.embeddingDescriptionPath);\n                this.description = JSON.parse(descriptionItem[this.embeddingDescriptionPath]);\n            }\n            catch(err){\n                this.logger.debug({'load description from storage': false});\n                this.description = await this.queryDescription();\n            }\n        }\n        if(forceFecth){\n            this.description = await this.queryDescription();\n        }\n        this.TokenChunkIdMapper = (token)=>{\n            return this.F.getIn([token], this.description.chunkLookUp, null);\n        };\n        this.vecsize = this.description.vecsize;//only set from here\n        return this.description;\n    }\n    /**\n     * fetch or read configure depends on provied link format\n     * @private\n     * @param {*} link\n     * @returns\n     * @memberof CausalNetEmbedding\n     */\n    async query(link){\n        if(link.startsWith('http')){\n            return await jsonUtils.fetchJson(link);\n        }\n        else{\n            return await jsonUtils.readJSON(link);\n        }\n    }\n    /**\n     * query the description json \n     * @private\n     * @returns { Object } description json object\n     * @memberof CausalNetEmbedding\n     */\n    async queryDescription(){\n        const DescriptionLink = this.baseLink + 'wordvec.description.json';\n        this.logger.debug({ DescriptionLink });\n        var description = this.query(DescriptionLink);\n        await this.Storage.setItem(this.embeddingDescriptionPath, JSON.stringify(description));\n        this.description = description;\n        return this.description;\n    }\n}\n\nexport default new CausalNetEmbedding(fetch, indexDBStorage, memDownCache, functor);","export { default as RepresentationMixins } from './representation.mixins';\nexport { default as causalNetEmbedding } from './causalNetEmbedding';\nexport { default as universalEmbedding } from './universalEmbedding';\nexport { default as WordEmbeddingMixins } from './wordEmbedding.mixins';\nexport { ChunkLookupMixins, TokenLookUpMixins } from './Lookup';\nexport { default as WordEmbeddingFunctorMixins } from './wordEmbeddingFunctor.mixins';"],"sourceRoot":""}