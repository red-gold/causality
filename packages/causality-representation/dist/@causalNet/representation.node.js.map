{"version":3,"sources":["webpack://@causalNet/representation/webpack/universalModuleDefinition","webpack://@causalNet/representation/webpack/bootstrap","webpack://@causalNet/representation/external \"causal-net.utils\"","webpack://@causalNet/representation/external \"causal-net.core\"","webpack://@causalNet/representation/external \"causal-net.storage\"","webpack://@causalNet/representation/external \"causal-net.memcache\"","webpack://@causalNet/representation/./src/universalEmbedding.js","webpack://@causalNet/representation//home/huynhnguyen/github/causality/node_modules/@babel/runtime/helpers/objectSpread.js","webpack://@causalNet/representation/external \"@tensorflow-models/universal-sentence-encoder\"","webpack://@causalNet/representation//home/huynhnguyen/github/causality/node_modules/@babel/runtime/helpers/defineProperty.js","webpack://@causalNet/representation/(webpack)/buildin/global.js","webpack://@causalNet/representation/./src/representation.mixins.js","webpack://@causalNet/representation/./src/wordEmbedding.mixins.js","webpack://@causalNet/representation/./src/Lookup/chunkLookup.mixins.js","webpack://@causalNet/representation/./src/Lookup/tokenLookup.mixins.js","webpack://@causalNet/representation/./src/wordEmbeddingFunction.mixins.js","webpack://@causalNet/representation/./src/function.js","webpack://@causalNet/representation/./src/causalNetEmbedding.js","webpack://@causalNet/representation/./src/index.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__2__","__WEBPACK_EXTERNAL_MODULE__3__","__WEBPACK_EXTERNAL_MODULE__6__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","global","_tensorflow_models_universal_sentence_encoder__WEBPACK_IMPORTED_MODULE_0__","causal_net_utils__WEBPACK_IMPORTED_MODULE_1__","causal_net_core__WEBPACK_IMPORTED_MODULE_2__","__webpack_exports__","Platform","mixWith","Tensor","constructor","super","use","model","[object Object]","fetch","fetch","load","sentences","Error","embed","target","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","forEach","obj","configurable","writable","g","Function","e","window","RepresentationMixins","BasePipelineClass","Representation","representation","assert","beInstanceOf","connect","configureLink","embeddingConfig","logger","log","setRepresentationByConfig","netConfig","EmbeddingConfig","Embedding","String","WordEmbeddingMixins","BaseEmbeddingClass","unknowVec","F","zeroVec","VecSize","T","encodedSentences","tokens","vecs","transform","encode","tensor","mean","push","stack","TokenLookUp","ChunkLookUp","missCacheTokens","token","vec","debug","tokenChunkIds","chunkIds","mapTokenToChunkIds","TokenChunkIdMapper","masterchunk","chunkId","console","chunk","queryChunk","updateChunkLookUp","objectSpread_default","reduce","finalVecs","_vec","undefined","ChunkLookupMixins","BaseWordEmbeddingClass","Storage","Promise","async","resolve","reject","ChunkPath","embeddingSavePath","getItem","JSON","parse","err","UpdateChunkPath","setItem","ChunkUrl","baseLink","query","TokenLookUpMixins","MemCache","error","WordEmbeddingFunctionMixins","BaseFunctionClass","mapper","R","tokenChunkMap","map","_chunkIds","unzip","uniq","vecSize","range","BaseFunction","causalNetEmbedding","StorageMixins","MemCacheMixins","ChunkLookUpMixins","indexDBStorage","memDownCache","embeddingDescriptionPath","vecsize","link","refresh","getDescription","forceFecth","description","descriptionItem","load description from storage","queryDescription","getIn","chunkLookUp","startsWith","JSONUtils","fetchJson","readJSON","DescriptionLink","stringify","representation_mixins","universalEmbedding","wordEmbedding_mixins","chunkLookup_mixins","tokenLookup_mixins","wordEmbeddingFunction_mixins"],"mappings":"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","file":"@causalNet/representation.node.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"causal-net.utils\"), require(\"causal-net.core\"), require(\"causal-net.storage\"), require(\"causal-net.memcache\"), require(\"@tensorflow-models/universal-sentence-encoder\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"causal-net.utils\", \"causal-net.core\", \"causal-net.storage\", \"causal-net.memcache\", \"@tensorflow-models/universal-sentence-encoder\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@causalNet/representation\"] = factory(require(\"causal-net.utils\"), require(\"causal-net.core\"), require(\"causal-net.storage\"), require(\"causal-net.memcache\"), require(\"@tensorflow-models/universal-sentence-encoder\"));\n\telse\n\t\troot[\"@causalNet/representation\"] = factory(root[\"causal-net.utils\"], root[\"causal-net.core\"], root[\"causal-net.storage\"], root[\"causal-net.memcache\"], root[\"@tensorflow-models/universal-sentence-encoder\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__3__, __WEBPACK_EXTERNAL_MODULE__6__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","import * as use from '@tensorflow-models/universal-sentence-encoder';\nimport { Platform } from 'causal-net.utils';\nimport { Tensor } from 'causal-net.core';\nimport { fetch } from 'causal-net.utils';\n/**\n *\n * This UniversialEmbedding provide methods for transform sentences into \n * its single vector representation \n * based on [use](https://github.com/tensorflow/tfjs-models/tree/master/universal-sentence-encoder)\n * @class UniversialEmbedding\n * @extends Tensor\n */\nclass UniversialEmbedding extends Platform.mixWith(Tensor, []){\n    \n    constructor(){\n        super();\n        /**\n         * @private { TensorModel } \n         */\n        this.use = use;\n        this.model = null;\n    }\n    \n    async connect(){\n        if(global){\n            //TODO: make better with Platform\n            global.fetch = fetch.fetch;\n        }\n        this.model = await this.use.load();\n        return this;\n    }\n\n    async sentenceEncode(sentences){\n        if(!this.model){\n            throw Error(`model is not connect`);\n        }\n        let embeddings = await this.model.embed(sentences);\n        return embeddings;\n    }\n}\nexport default new UniversialEmbedding();","var defineProperty = require(\"./defineProperty\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nmodule.exports = _objectSpread;","module.exports = __WEBPACK_EXTERNAL_MODULE__6__;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { Tensor } from 'causal-net.core'; \nimport { assert } from 'causal-net.utils';\n/**\n * This RepresentationMixins provide mixins for composing pipeline with representation transform for text\n * @class RepresentationMixins\n * @extends  BasePipelineClass\n * @example\n * [EXAMPLE ../examples/embeddingMixins.babel.node.js]\n */\nconst RepresentationMixins = (BasePipelineClass)=> class extends BasePipelineClass{ \n    /**\n     * Return Embedding instance\n     *\n     * @readonly\n     * @memberof RepresentationMixins\n     */\n    get Representation(){\n        if(!this.representation){\n            throw Error('representation is not set');\n        }\n        return this.representation;\n    }\n    \n    set Representation(representation){\n        assert.beInstanceOf(representation, Tensor);\n        this.representation = representation;\n    }\n    /**\n     * Load configure of pretrained vector from either local folder or remote server. \n     * After connect, the result is cached for next time init.\n     * @param { URL|FilePath } link - link to load\n     * @param { boolean } [refresh=false] - force to discard local cache\n     * @returns { Promise }\n     * @memberof RepresentationMixins\n     */\n    async connect(){\n        if(super.connect){\n            super.connect();\n        }\n        let configureLink = this.embeddingConfig;\n        this.logger.log(`representation connect to ${configureLink}`);\n        await this.Representation.connect(configureLink);\n    }\n    /**\n     * set embedding for pipeline\n     * @param { Object } netConfig - contain Embedding instance and Embedding configure\n     * @memberof RepresentationMixins\n     */\n    setRepresentationByConfig(netConfig){\n        let { EmbeddingConfig, Embedding } = netConfig.Representation;\n        assert.beInstanceOf(EmbeddingConfig, String);\n        this.Representation = Embedding;\n        this.embeddingConfig = EmbeddingConfig;\n    }\n};\nexport default RepresentationMixins;    ","/**\n * This WordEmbeddingMixins class is provide methods for transforn sentences, tokens to vectors\n * @class CausalNetEmbedding\n * @extends  BaseEmbeddingClass\n */\nconst WordEmbeddingMixins = (BaseEmbeddingClass)=> class extends BaseEmbeddingClass{ \n    /**\n     * return default replacement for unknown vec. Currently it is set to zeros\n     * @returns { Array } vec\n     */\n    unknowVec(){\n        return this.F.zeroVec(this.VecSize);\n    }\n    \n    /**\n     * return the vectors of tokenized sentences\n     * This function require sentence to be tokenized via preprocessing\n     * @param { Array } tokens - array of string tokens of sentence\n     * @returns { Tensor } encoded sentences\n     */\n    async sentenceEncode(sentences){\n        const T = this.T;\n        let encodedSentences = [];\n        for(let tokens of sentences){\n            let vecs = await this.transform(tokens);\n            let encode = await T.tensor(vecs).mean(0);\n            encodedSentences.push(encode);\n        }\n        return T.stack(encodedSentences);\n    }\n    /**\n     * Transform tokenized sentences into tensor vectors\n     * @param { Array } tokens - 2d array for token of sentences\n     * @returns { Tensor } 2d tensor represent vectors of each input sentences\n     * @example\n     * let sentVec = await causalNetEmbedding.sentenceEncode([ ['this', 'is', 'test'] ]);\n     */\n    async transform(tokens){\n        const TokenLookUp = this.TokenLookUp, ChunkLookUp = this.ChunkLookUp;\n        \n        let vecs = [], missCacheTokens=[];\n        for(let token of tokens){\n            let vec = await TokenLookUp(token);\n            this.logger.debug({[token]: vec});\n            if(vec === null){\n                missCacheTokens = [...missCacheTokens, token];\n            }\n            vecs = [...vecs, token];\n        }\n        if(missCacheTokens.length === 0){\n            return vecs;\n        }\n        \n        let {tokenChunkIds, chunkIds} = \n            this.F.mapTokenToChunkIds(missCacheTokens, this.TokenChunkIdMapper);\n        \n        this.logger.debug({tokenChunkIds, chunkIds});\n        let masterchunk = {};\n        for(let chunkId of chunkIds){\n            if(chunkId !== null){//not in chunk\n                console.log('lookup');\n                let chunk = await ChunkLookUp(chunkId);\n                if(chunk === null){\n                    chunk = await this.queryChunk(chunkId);\n                    await this.updateChunkLookUp(chunkId, chunk);\n                }\n                masterchunk = {...masterchunk, ...chunk};\n            }\n        }\n        \n        let finalVecs = vecs.reduce((finalVecs, vec)=>{\n                            if( typeof(vec) === \"string\" ){\n                                let _vec = masterchunk[vec];\n                                if(_vec === undefined){\n                                    _vec = this.unknowVec();\n                                }\n                                finalVecs.push(_vec);\n                            }\n                            else{\n                                finalVecs.push(vec);\n                            }\n                            return finalVecs;\n                        }, []);\n        return finalVecs;\n    }   \n};\nexport default WordEmbeddingMixins;","/**\n * This ChunkLookupMixins class provide mixins for chunk lookup that first look from the cached chunk then\n * fetch and cache new chunk\n * @class ChunkLookupMixins\n * @extends {  BaseWordEmbeddingClass } \n */\nconst ChunkLookupMixins = ( BaseWordEmbeddingClass )=> class extends BaseWordEmbeddingClass{ \n    \n    /**\n     * Return the storage lookup function\n     * @readonly\n     */\n    get ChunkLookUp(){\n        const Storage = this.Storage;\n        return (chunkId)=>{\n            return new Promise(async (resolve, reject)=>{\n                try{\n                    const ChunkPath = this.embeddingSavePath + chunkId;\n                    let chunkItem = await Storage.getItem(ChunkPath);\n                    let chunk = chunkItem[ChunkPath];\n                    resolve(JSON.parse(chunk));\n                }\n                catch(err){\n                    resolve(null);\n                }\n            });\n        };\n    }\n   /**\n    * Update the storage lookup\n    * @param { String|Number } chunkId - id in positive integer range\n    * @param { Object } chunk - chunk object containing token keys and correponding vec value\n    * @returns { String } - updated chunk path in storage\n    */\n   async updateChunkLookUp(chunkId, chunk){\n        const Storage = this.Storage;\n        const UpdateChunkPath = this.embeddingSavePath + chunkId;\n        return await Storage.setItem(UpdateChunkPath, chunk);\n    }\n    /**\n     * Query chunk either read from file or fetch from remote server\n     * @param { String|Number } chunkId - id in positive interger range\n     * @returns { Object }  chunk object containing token keys and correponding vec value\n     */\n    async queryChunk(chunkId){\n        const ChunkUrl = `${this.baseLink}wordvec_chunk_${chunkId}.json`;\n        return await this.query(ChunkUrl);\n    }\n   \n};\nexport default ChunkLookupMixins;","const TokenLookUpMixins = (BaseWordEmbeddingClass)=> class extends BaseWordEmbeddingClass{ \n    get TokenLookUp(){\n        const MemCache = this.MemCache;\n        return (token)=>{\n            return new Promise(async (resolve, reject)=>{\n                try{\n                    let vec = await MemCache.getItem(this.embeddingSavePath + token);\n                    resolve(vec);\n                }\n                catch(err){\n                    resolve(null);\n                }\n            });\n        };\n    }\n    /**\n     *\n     * @param { String } token - \n     * @param { Array } vec - vector representation of token\n     */\n    async updateTokenLookUp(token, vec){\n        console.error('this is update');\n        const MemCache = this.MemCache;\n        await MemCache.setItem(this.embeddingSavePath + token, vec);\n    }\n};\nexport default TokenLookUpMixins;\n","const WordEmbeddingFunctionMixins = (BaseFunctionClass) => class extends BaseFunctionClass{\n    /**\n     *\n     * @param { Array } tokens - list of tokens to find coresponding ids\n     * @param { Function } mapper - \n     * @returns \n     */\n    mapTokenToChunkIds(tokens, mapper){\n        const R = this.R;\n        const TokenChunkIdMapper = mapper;\n        let tokenChunkMap = tokens.map( t => {\n            let chunkId = TokenChunkIdMapper(t);\n            return [[t, chunkId], chunkId]; \n        });\n        let [tokenChunkIds, _chunkIds] = this.unzip(tokenChunkMap);\n        let chunkIds = R.uniq(_chunkIds);\n        console.log({chunkIds, tokenChunkIds});\n        return {tokenChunkIds, chunkIds};\n    }\n    /**\n     * return zero vector given the vec size\n     * @param { Number } vecSize - positive integer indicates vector length\n     * @returns { Array } zero vector\n     */\n    zeroVec(vecSize){\n        return this.R.map(()=>0,this.R.range(0, vecSize));\n    };\n};\nexport default WordEmbeddingFunctionMixins;","import { Function as BaseFunction } from 'causal-net.core';\nimport { Platform } from 'causal-net.utils';\nimport { default as WordEmbeddingFunctionMixins } from './wordEmbeddingFunction.mixins';\n/**\n * This Function class provides methods for common used ultilities function\n * @export\n * @class Function\n * @extends BaseFunction\n */\nexport default class Function extends Platform.mixWith(BaseFunction, \n        [WordEmbeddingFunctionMixins]){\n    constructor(){\n        super();\n    }\n}","import { Tensor } from 'causal-net.core';\nimport { Platform, fetch, JSONUtils } from 'causal-net.utils';\nimport { StorageMixins, indexDBStorage } from 'causal-net.storage';\nimport { MemCacheMixins, memDownCache } from 'causal-net.memcache';\nimport { default as WordEmbeddingMixins } from './wordEmbedding.mixins';\nimport { default as ChunkLookUpMixins } from './Lookup/chunkLookup.mixins';\nimport { default as TokenLookUpMixins } from './Lookup/tokenLookup.mixins';\nimport { default as Function } from './function';\n/**\n * This CausalNetEmbedding provide methods for transform raw tokenized sentence into \n * its single vector representation\n * mixWith:\n *         [   StorageMixins, \n *             MemCacheMixins,\n *             TokenLookUpMixins,\n *             ChunkLookUpMixins,\n *             WordEmbeddingMixins ])}\n * @class CausalNetEmbedding\n * @extends  Tensor\n * @example\n * [EXAMPLE ../examples/causalNetEmbedding.babel.node.js]\n */\nclass CausalNetEmbedding extends Platform.mixWith(Tensor, \n        [   StorageMixins, \n            MemCacheMixins,\n            TokenLookUpMixins,\n            ChunkLookUpMixins,\n            WordEmbeddingMixins ]){\n    constructor(){\n        super();\n        this.fetch = fetch;\n        this.Storage = indexDBStorage;   //store configure\n        this.MemCache = memDownCache;    //store chunks\n        this.F = new Function();\n        this.embeddingSavePath = '/embedding/';\n        this.embeddingDescriptionPath = this.embeddingSavePath + 'description.json';\n    }\n    /**\n     * Return veczie in positive number\n     *\n     * @readonly\n     * @memberof CausalNetEmbedding\n     */\n    get VecSize(){\n        if(!this.vecsize){\n            throw Error('vecsize is not set');\n        }\n        return this.vecsize;\n    }\n    /**\n     * Load configure of pretrained vector from either local folder or remote server. \n     * After connect, the result is cached for next time init.\n     * @param { URL|FilePath } link - link to load\n     * @param { boolean } [refresh=false] - force to discard local cache\n     * @returns { Promise }\n     * @memberof CausalNetEmbedding\n     */\n    async connect(link, refresh=false){\n        this.baseLink = link;\n        return await this.getDescription(refresh);\n    }\n    /**\n     * This method is called by connect\n     * @private\n     * @param {boolean} [forceFecth=false]\n     * @returns\n     * @memberof CausalNetEmbedding\n     */\n    async getDescription(forceFecth=false){\n        if(!this.description){\n            try{\n                let descriptionItem = await this.Storage.getItem(this.embeddingDescriptionPath);\n                this.description = JSON.parse(descriptionItem[this.embeddingDescriptionPath]);\n            }\n            catch(err){\n                this.logger.debug({'load description from storage': false});\n                this.description = await this.queryDescription();\n            }\n        }\n        if(forceFecth){\n            this.description = await this.queryDescription();\n        }\n        this.TokenChunkIdMapper = (token)=>{\n            return this.F.getIn([token], this.description.chunkLookUp, null);\n        };\n        this.vecsize = this.description.vecsize;//only set from here\n        return this.description;\n    }\n    /**\n     * fetch or read configure depends on provied link format\n     * @private\n     * @param {*} link\n     * @returns\n     * @memberof CausalNetEmbedding\n     */\n    async query(link){\n        if(link.startsWith('http')){\n            return await JSONUtils.fetchJson(link);\n        }\n        else{\n            return await JSONUtils.readJSON(link);\n        }\n    }\n    /**\n     * query the description json \n     * @private\n     * @returns { Object } description json object\n     * @memberof CausalNetEmbedding\n     */\n    async queryDescription(){\n        const DescriptionLink = this.baseLink + 'wordvec.description.json';\n        this.logger.debug({ DescriptionLink });\n        var description = this.query(DescriptionLink);\n        await this.Storage.setItem(this.embeddingDescriptionPath, JSON.stringify(description));\n        this.description = description;\n        return this.description;\n    }\n}\n\nexport default new CausalNetEmbedding();","export { default as RepresentationMixins } from './representation.mixins';\nexport { default as causalNetEmbedding } from './causalNetEmbedding';\nexport { default as universalEmbedding } from './universalEmbedding';\nexport { default as WordEmbeddingMixins } from './wordEmbedding.mixins';\nexport { ChunkLookupMixins, TokenLookUpMixins } from './Lookup';\nexport { default as WordEmbeddingFunctionMixins } from './wordEmbeddingFunction.mixins';"],"sourceRoot":""}