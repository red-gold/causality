!function(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r(require("causal-net.core"),require("causal-net.utils"),require("causal-net.storage")):"function"==typeof define&&define.amd?define(["causal-net.core","causal-net.utils","causal-net.storage"],r):"object"==typeof exports?exports["@causalNet/layer"]=r(require("causal-net.core"),require("causal-net.utils"),require("causal-net.storage")):e["@causalNet/layer"]=r(e["causal-net.core"],e["causal-net.utils"],e["causal-net.storage"])}(this,function(e,r,t){return function(e){var r={};function t(a){if(r[a])return r[a].exports;var s=r[a]={i:a,l:!1,exports:{}};return e[a].call(s.exports,s,s.exports,t),s.l=!0,s.exports}return t.m=e,t.c=r,t.d=function(e,r,a){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:a})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(t.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var s in e)t.d(a,s,function(r){return e[r]}.bind(null,s));return a},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=3)}([function(r,t){r.exports=e},function(e,t){e.exports=r},function(e,r){e.exports=t},function(e,r,t){"use strict";t.r(r);var a=t(0),s=t(1);var i=e=>(class extends e{dense(e,r,t="sigmoid",a=null){return a||(a=this.nameGenerator("dense")),{Name:a,Type:"Layer",Parameters:{Weight:[e,r],Bias:[r]},Net:(e,r)=>{let{Weight:a,Bias:s}=r,i=e.dot(a).add(s);return{result:i=i[t](),trace:{}}}}}});var n=new class extends(s.platform.mixWith(a.Tensor,[i])){constructor(){super(),this.layerNames=[]}nameGenerator(e){let r=e+"/"+this.layerNames.length;return this.layerNames.push(r),r}},o=t(2);var u=e=>(class extends e{get PredictParameters(){if(!this.parameters||!this.parameters.Predict)throw Error("parameters is not set");return this.parameters.Predict}get EncodeParameters(){if(!this.parameters||!this.parameters.Encode)throw Error("parameters is not set");return this.parameters.Encode}get DecodeParameters(){if(!this.parameters||!this.parameters.Decode)throw Error("parameters is not set");return this.parameters.Decode}set PredictParameters(e){this.parameters=this.parameters?this.parameters:{},this.parameters.Predict=e}set EncodeParameters(e){this.parameters=this.parameters?this.parameters:{},this.parameters.Encode=e}set DecodeParameters(e){this.parameters=this.parameters?this.parameters:{},this.parameters.Decode=e}set ParameterSizes(e){this.parameterSizes=e}get ParameterSizes(){if(!this.parameterSizes)throw Error("parameterSizes is not set");return this.parameterSizes}get SaveModelDir(){return"saveModel/"}exportParameters(){if(!this.parameters)throw Error("parameter is not set");return(async()=>await this.extractParamFromTensorDict(this.parameters,async e=>Array.from(await e.data())))()}async extractParamFromTensorDict(e,r){const t=this.R,a=async(e,r)=>{if(this.isTensor(e))return await r(e);{let s=t.toPairs(e),i={};for(let[e,t]of s)i[e]=await a(t,r);return i}};return await a(e,r)}async parametersSummary(){if(!this.parameters)throw Error("parameter must be set");return await this.extractParamFromTensorDict(this.parameters,async e=>Array.from(await e.mean().data()))}initParamSizesByLayers(e){const r=this.R,t=(this.T,this.F),a=r.compose(r.fromPairs,r.map(e=>[e.Name,e.Parameters])),s=a(t.getIn(["Predict"],e,[])),i=a(t.getIn(["Encode"],e,[])),n=a(t.getIn(["Decode"],e,[]));this.ParameterSizes={PredictSize:s,EncodeSize:i,DecodeSize:n}}importParameters(e){const r=this.T,t=this.F;let a=t.getIn(["Predict"],e,{}),s=t.getIn(["Encode"],e,{}),i=t.getIn(["Decode"],e,{});const{PredictSize:n,EncodeSize:o,DecodeSize:u}=this.ParameterSizes,c=(e,a)=>t.parameterMapWithKey((e,t)=>{let s=this.F.getIn(e,a,null);return null===s?r.variable(r.randomNormal(t).asType("float32")):r.variable(r.tensor(s,t,"float32"))},e);this.PredictParameters=c(n,a),this.EncodeParameters=c(o,s),this.DecodeParameters=c(u,i)}InitParameters(e={}){return r=>this.setOrInitParams(r,e)}setOrInitParams(e,r){return this.initParamSizesByLayers(e),this.importParameters(r),this}async getSavedParamList(){const e=this.Storage,r=this.SaveModelDir;return(await e.getFileList(r)).map(e=>e.replace(r,""))}async saveParams(e){const r=this.SaveModelDir,t=this.Storage;let a=await this.exportParameters();return await t.writeFile(r+e,JSON.stringify(a)),a}async loadParams(e){const r=this.Storage,t=this.SaveModelDir;let a=await r.readFile(t+e),s=JSON.parse(a);return this.importParameters(s),this}});var c=e=>(class extends e{isParameter(e){const r=this.R;return r.ifElse(r.is(Array),r.all(r.is(Number)),r.always(!1))(e)}parameterMapWithKey(e,r){const t=this.R,a=(r,s)=>t.compose(t.fromPairs,t.map(([s,i])=>this.isParameter(i)?[s,e([...r,s],i)]:t.is(Object,i)?[s,a([...r,s],i)]:[s,i]),t.toPairs)(s);return a([],r)}});var m=new class extends(s.platform.mixWith(a.Functor,[c])){constructor(){super()}};var l=new class extends(s.platform.mixWith(a.Tensor,[o.StorageMixins,u])){constructor(e,r){super(),this.parameters=null,this.Storage=e,this.F=r,this.R=this.F.CoreFunctor}}(o.indexDBStorage,m);var h=e=>(class extends e{set NetParameters(e){this.netParameters=e}set NetLayers(e){this.netLayers=e}get NetParameters(){if(!this.netParameters)throw Error("netParameters is not set");return this.netParameters}get NetLayers(){if(!this.netLayers)throw Error("netLayers is not set");return this.netLayers}runOpFlow(e,r,t){const a=this.R,s=a.addIndex(a.reduce)(a.__,{result:e,trace:{}},r);var{result:i,trace:n}=s(({result:e,trace:r},a,s)=>{if(a.Parameter){let r=t[a.Parameter];e=e[a.Op](r,...a.Args)}else e=e[a.Op](...a.Args);return r[s]=e.shape,{result:e,trace:r}});return{result:i,trace:n}}runOpLayer(e,r,t){let{result:a,trace:s}=r(e,t);return{result:a,trace:s}}runLayer(e,r,t){const{Name:a,Type:s,Flow:i,Net:n}=r;if("Tensor"===s){let{result:r,trace:s}=this.runOpFlow(e,i,t);return{[a]:r,trace:s}}if("Layer"===s){let{result:r,trace:s}=this.runOpLayer(e,n,t);return{[a]:r,trace:s}}throw Error("type must be either Layer or Tensor")}tracing(e,r,t){e&&e.push({[r]:t})}run(e,r,t,a=null){let s={PipeInput:r},i="PipeInput";for(let r of e){let e=this.runLayer(s[i],r,t[r.Name]);s[r.Name]=e[r.Name],i=r.Name,this.tracing(a,r.Name,e.trace)}return a&&this.logger.debug({traces:a}),s[i]}get Predictor(){let e=this.NetLayers.Predict;const r=()=>this.NetParameters.PredictParameters;return t=>{let a=r();return this.run(e,t,a)}}get Encoder(){let e=this.NetLayers.Encode;const r=()=>this.NetParameters.EncodeParameters;return t=>{let a=r();return this.run(e,t,a)}}get Decoder(){let e=this.NetLayers.Decode;const r=()=>this.NetParameters.EncodeParameters;return t=>{let a=r();return this.run(e,t,a)}}});var p=new class extends(s.platform.mixWith(a.Tensor,[h])){constructor(){super()}};var d=e=>(class extends e{async saveParams(e){return await this.LayerRunner.NetParameters.saveParams(e),this}async loadParams(e){return this.LayerRunner.NetParameters=await this.LayerRunner.NetParameters.loadParams(e),this}async getSavedParamList(){return await this.LayerRunner.NetParameters.getSavedParamList()}get ParameterInitializer(){if(!this.parameterInitializer)throw Error("ParameterInitializer is not set");return this.parameterInitializer}set ParameterInitializer(e){this.parameterInitializer=e}setByConfig(e){super.setByConfig&&super.setByConfig(e),this.Logger.groupBegin("set LayerRunner by config");const{Net:r}=e,{Layers:t,Parameters:a}=r;this.LayerRunner.NetLayers=t,this.ParameterInitializer=a,this.LayerRunner.NetParameters=this.ParameterInitializer(t),this.Logger.groupEnd()}set LayerRunner(e){this.layerRunner=e}get LayerRunner(){if(!this.layerRunner)throw Error("layerRunner is not set");return this.layerRunner}});t.d(r,"causalNetLayers",function(){return n}),t.d(r,"causalNetParameters",function(){return l}),t.d(r,"ParameterMixins",function(){return u}),t.d(r,"ParameterFunctorMixins",function(){return c}),t.d(r,"causalNetRunner",function(){return p}),t.d(r,"RunnerMixins",function(){return h}),t.d(r,"LayerRunnerMixins",function(){return d})}])});
//# sourceMappingURL=layer.web.js.map