<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: causality.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: causality.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {BaseTensor, Layer} from 'causal-net-core';
import {default as Function} from './function';

export default class CausalNet{
    /**
     * @param  {} netConfig
     * @param  {} netParams
     */
    constructor( netConfig, netParams ){
        this.l = new Layer();
        this.f = new Function();
        this.HyperParameters = this.f.getHyperParameter(netConfig);
        this.BasePipeline = this.f.getPipeline(netConfig);
        this.netParams = netParams;
        this.netParams = this.l.setOrInitParams(this.BasePipeline, netParams);
        const baseTensor = new BaseTensor();
        this.T = baseTensor.Tensor;
    }
    /**
     * @param  {} samples
     * @param  {} numSamples=1
     * @param  {} log=null
     */
    makePredict(samples, numSamples=1, log=null){
        const T = this.T, f = this.f, l = this.l;
        this.HyperParameters.Datasize = numSamples;
        const Pipeline = f.parameterAcquisition(this.BasePipeline, this.HyperParameters);
        console.log(JSON.stringify({Pipeline}));
        let pipeValue = {PipeInput: samples}, traces = [], netParams = this.netParams;
        return T.tidy(()=>{
            for(let layer of Pipeline){
                let layerOutput = l.layer(pipeValue[layer.Input], layer, netParams[layer.Name], ()=>{});
                pipeValue[layer.Name] = layerOutput[layer.Name];
                traces.push({[layer.Name]: layerOutput.trace});
            }
            console.log(JSON.stringify({traces}));
            let pipeOutput = pipeValue['PipeOutput'];
            let logProb = pipeOutput.sub(T.logSumExp(pipeOutput, 1, true));
            let predict = logProb.argMax(1);
            return {logProb, predict};
        });
    }

    loss(sampleBatch, labelBatch, numSample, log=null){
        const T = this.T;
        let label = T.tensor(labelBatch).reshape([numSample, -1]);
        const {logProb} = this.makePredict(sampleBatch, numSample, log);
        const likelihood = logProb.neg().mul(label);
        const loss = likelihood.mean();
        // if(log){ log({shape: sampleBatch.shape[0]}); };
        return loss;
    };

    train(doSampleGenerator, batchSize, numEpochs = 2, lr=0.01){
        const T = this.T, f = this.f, R = this.f.Function;
        const start = new Date();
        let loss = [], averageLoss = [];
        const optimizer = T.train.adam(lr);
        for(let epochIdx of f.range(numEpochs)){
            console.log({epochIdx, averageLoss, time: new Date().toISOString(), start: start.toISOString(),
                         elapse: (new Date() - start)/1000});
            const sampleGenerator = doSampleGenerator(batchSize);
            for(let [batchData, batchLabels] of sampleGenerator){
                console.log({dlen: batchData.length, llen: batchLabels.length});
                optimizer.minimize(()=>{
                    let l = this.loss(batchData, batchLabels, batchSize, (msg)=>{console.log(msg);});
                    loss = [...loss, ...l.dataSync()];
                    console.log({loss});
                    return l;
                });
            }
            averageLoss = [...averageLoss, R.mean(loss)];
            loss = [];
        }
    };

    test(testData, testLabels){
        let {predict} = this.makePredict(testData);
        predict = predict.dataSync();
        let corrects = testLabels.map((testLabel,idx)=>{
            return testLabel === predict[idx];
        });
        return {corect: R.sum(corrects), total: testLabels.length};
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module.exports_module.exports.html">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#makePredict">makePredict</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Dec 16 2018 22:52:47 GMT+0700 (Indochina Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
